var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

var {
  SelectionManager,
  useMultipleSelectionState
} = require("@react-stately/selection");

var {
  useEffect,
  useMemo
} = require("react");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

/**
 * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.
 */
function useGridState(props) {
  let {
    collection,
    focusMode
  } = props;
  let selectionState = useMultipleSelectionState(props);
  let disabledKeys = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);
  let setFocusedKey = selectionState.setFocusedKey;

  selectionState.setFocusedKey = (key, child) => {
    // If focusMode is cell and an item is focused, focus a child cell instead.
    if (focusMode === 'cell' && key != null) {
      let item = collection.getItem(key);

      if ((item == null ? void 0 : item.type) === 'item') {
        let children = [...item.childNodes];

        if (child === 'last') {
          var _children;

          key = (_children = children[children.length - 1]) == null ? void 0 : _children.key;
        } else {
          var _children$;

          key = (_children$ = children[0]) == null ? void 0 : _children$.key;
        }
      }
    }

    setFocusedKey(key, child);
  }; // Reset focused key if that item is deleted from the collection.


  useEffect(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
      selectionState.setFocusedKey(null);
    }
  }, [collection, selectionState.focusedKey]);
  return {
    collection,
    disabledKeys,
    selectionManager: new SelectionManager(collection, selectionState)
  };
}

exports.useGridState = useGridState;
let $b9f358a1a5a44d4c3a26859$var$_Symbol$iterator;
$b9f358a1a5a44d4c3a26859$var$_Symbol$iterator = Symbol.iterator;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
class GridCollection {
  constructor(opts) {
    this.keyMap = new Map();
    this.columnCount = void 0;
    this.rows = void 0;
    this.keyMap = new Map();
    this.columnCount = opts == null ? void 0 : opts.columnCount;
    this.rows = [];

    let visit = node => {
      // If the node is the same object as the previous node for the same key,
      // we can skip this node and its children. We always visit columns though,
      // because we depend on order to build the columns array.
      let prevNode = this.keyMap.get(node.key);

      if (opts.visitNode) {
        node = opts.visitNode(node);
      }

      this.keyMap.set(node.key, node);
      let childKeys = new Set();
      let last;

      for (let child of node.childNodes) {
        if (child.type === 'cell' && child.parentKey == null) {
          // if child is a cell parent key isn't already established by the collection, match child node to parent row
          child.parentKey = node.key;
        }

        childKeys.add(child.key);

        if (last) {
          last.nextKey = child.key;
          child.prevKey = last.key;
        } else {
          child.prevKey = null;
        }

        visit(child);
        last = child;
      }

      if (last) {
        last.nextKey = null;
      } // Remove deleted nodes and their children from the key map


      if (prevNode) {
        for (let child of prevNode.childNodes) {
          if (!childKeys.has(child.key)) {
            remove(child);
          }
        }
      }
    };

    let remove = node => {
      this.keyMap.delete(node.key);

      for (let child of node.childNodes) {
        if (this.keyMap.get(child.key) === child) {
          remove(child);
        }
      }
    };

    let last;
    opts.items.forEach((node, i) => {
      let rowNode = _babelRuntimeHelpersExtends({
        level: 0,
        key: 'row-' + i,
        type: 'row',
        value: undefined,
        hasChildNodes: true,
        childNodes: [...node.childNodes],
        rendered: undefined,
        textValue: undefined
      }, node, {
        index: i
      });

      if (last) {
        last.nextKey = rowNode.key;
        rowNode.prevKey = last.key;
      } else {
        rowNode.prevKey = null;
      }

      this.rows.push(rowNode);
      visit(rowNode);
      last = rowNode;
    });

    if (last) {
      last.nextKey = null;
    }
  }

  *[$b9f358a1a5a44d4c3a26859$var$_Symbol$iterator]() {
    yield* [...this.rows];
  }

  get size() {
    return [...this.rows].length;
  }

  getKeys() {
    return this.keyMap.keys();
  }

  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }

  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }

  getFirstKey() {
    var _;

    return (_ = [...this.rows][0]) == null ? void 0 : _.key;
  }

  getLastKey() {
    var _rows;

    let rows = [...this.rows];
    return (_rows = rows[rows.length - 1]) == null ? void 0 : _rows.key;
  }

  getItem(key) {
    return this.keyMap.get(key);
  }

  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }

}

exports.GridCollection = GridCollection;
//# sourceMappingURL=main.js.map
