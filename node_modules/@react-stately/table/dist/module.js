import _react, { useMemo } from "react";
import { useGridState, GridCollection } from "@react-stately/grid";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
import { Section, useCollection } from "@react-stately/collections";
export { Section };
let $d7f61bffc1886b961473c48c52f8fd$var$_Symbol$iterator;
const $d7f61bffc1886b961473c48c52f8fd$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);

function $d7f61bffc1886b961473c48c52f8fd$var$buildHeaderRows(keyMap, columnNodes) {
  let columns = [];
  let seen = new Map();

  for (let column of columnNodes) {
    let parentKey = column.parentKey;
    let col = [column];

    while (parentKey) {
      let parent = keyMap.get(parentKey); // If we've already seen this parent, than it is shared
      // with a previous column. If the current column is taller
      // than the previous column, than we need to shift the parent
      // in the previous column so it's level with the current column.

      if (seen.has(parent)) {
        parent.colspan++;
        let {
          column,
          index
        } = seen.get(parent);

        if (index > col.length) {
          break;
        }

        for (let i = index; i < col.length; i++) {
          column.splice(i, 0, null);
        } // Adjust shifted indices


        for (let i = col.length; i < column.length; i++) {
          if (column[i] && seen.has(column[i])) {
            seen.get(column[i]).index = i;
          }
        }
      } else {
        parent.colspan = 1;
        col.push(parent);
        seen.set(parent, {
          column: col,
          index: col.length - 1
        });
      }

      parentKey = parent.parentKey;
    }

    columns.push(col);
    column.index = columns.length - 1;
  }

  let maxLength = Math.max(...columns.map(c => c.length));
  let headerRows = Array(maxLength).fill(0).map(() => []); // Convert columns into rows.

  let colIndex = 0;

  for (let column of columns) {
    let i = maxLength - 1;

    for (let item of column) {
      if (item) {
        // Fill the space up until the current column with a placeholder
        let row = headerRows[i];
        let rowLength = row.reduce((p, c) => p + c.colspan, 0);

        if (rowLength < colIndex) {
          let placeholder = {
            type: 'placeholder',
            key: 'placeholder-' + item.key,
            colspan: colIndex - rowLength,
            index: rowLength,
            value: null,
            rendered: null,
            level: i,
            hasChildNodes: false,
            childNodes: [],
            textValue: null
          };

          if (row.length > 0) {
            row[row.length - 1].nextKey = placeholder.key;
            placeholder.prevKey = row[row.length - 1].key;
          }

          row.push(placeholder);
        }

        if (row.length > 0) {
          row[row.length - 1].nextKey = item.key;
          item.prevKey = row[row.length - 1].key;
        }

        item.level = i;
        item.index = colIndex;
        row.push(item);
      }

      i--;
    }

    colIndex++;
  } // Add placeholders at the end of each row that is shorter than the maximum


  let i = 0;

  for (let row of headerRows) {
    let rowLength = row.reduce((p, c) => p + c.colspan, 0);

    if (rowLength < columnNodes.length) {
      let placeholder = {
        type: 'placeholder',
        key: 'placeholder-' + row[row.length - 1].key,
        colspan: columnNodes.length - rowLength,
        index: rowLength,
        value: null,
        rendered: null,
        level: i,
        hasChildNodes: false,
        childNodes: [],
        textValue: null,
        prevKey: row[row.length - 1].key
      };
      row.push(placeholder);
    }

    i++;
  }

  return headerRows.map((childNodes, index) => {
    let row = {
      type: 'headerrow',
      key: 'headerrow-' + index,
      index,
      value: null,
      rendered: null,
      level: 0,
      hasChildNodes: true,
      childNodes,
      textValue: null
    };
    return row;
  });
}

$d7f61bffc1886b961473c48c52f8fd$var$_Symbol$iterator = Symbol.iterator;

class $d7f61bffc1886b961473c48c52f8fd$export$TableCollection extends GridCollection {
  constructor(nodes, prev, opts) {
    let rowHeaderColumnKeys = new Set();
    let body;
    let columns = []; // Add cell for selection checkboxes if needed.

    if (opts != null && opts.showSelectionCheckboxes) {
      let rowHeaderColumn = {
        type: 'column',
        key: $d7f61bffc1886b961473c48c52f8fd$var$ROW_HEADER_COLUMN_KEY,
        value: null,
        textValue: '',
        level: 0,
        index: 0,
        hasChildNodes: false,
        rendered: null,
        childNodes: [],
        props: {
          isSelectionCell: true
        }
      };
      columns.unshift(rowHeaderColumn);
    }

    let rows = [];
    let columnKeyMap = new Map();

    let visit = node => {
      switch (node.type) {
        case 'body':
          body = node;
          break;

        case 'column':
          columnKeyMap.set(node.key, node);

          if (!node.hasChildNodes) {
            columns.push(node);

            if (node.props.isRowHeader) {
              rowHeaderColumnKeys.add(node.key);
            }
          }

          break;

        case 'item':
          rows.push(node);
          return;
        // do not go into childNodes
      }

      for (let child of node.childNodes) {
        visit(child);
      }
    };

    for (let node of nodes) {
      visit(node);
    }

    let headerRows = $d7f61bffc1886b961473c48c52f8fd$var$buildHeaderRows(columnKeyMap, columns);
    headerRows.forEach((row, i) => rows.splice(i, 0, row));
    super({
      columnCount: columns.length,
      items: rows,
      visitNode: node => {
        node.column = columns[node.index];
        return node;
      }
    });
    this.headerRows = void 0;
    this.columns = void 0;
    this.rowHeaderColumnKeys = void 0;
    this.body = void 0;
    this.columns = columns;
    this.rowHeaderColumnKeys = rowHeaderColumnKeys;
    this.body = body;
    this.headerRows = headerRows; // Default row header column to the first one.

    if (this.rowHeaderColumnKeys.size === 0) {
      this.rowHeaderColumnKeys.add(this.columns[opts != null && opts.showSelectionCheckboxes ? 1 : 0].key);
    }
  }

  *[$d7f61bffc1886b961473c48c52f8fd$var$_Symbol$iterator]() {
    yield* this.body.childNodes;
  }

  get size() {
    return [...this.body.childNodes].length;
  }

  getKeys() {
    return this.keyMap.keys();
  }

  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }

  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }

  getFirstKey() {
    var _;

    return (_ = [...this.body.childNodes][0]) == null ? void 0 : _.key;
  }

  getLastKey() {
    var _rows;

    let rows = [...this.body.childNodes];
    return (_rows = rows[rows.length - 1]) == null ? void 0 : _rows.key;
  }

  getItem(key) {
    return this.keyMap.get(key);
  }

  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }

}

const $ed569ec24a699f43593e019ef637b788$var$OPPOSITE_SORT_DIRECTION = {
  ascending: 'descending',
  descending: 'ascending'
};
/**
 * Provides state management for a table component. Handles building a collection
 * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.
 */

export function useTableState(props) {
  let {
    selectionMode = 'none'
  } = props;
  let context = useMemo(() => ({
    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',
    selectionMode,
    columns: []
  }), [props.children, props.showSelectionCheckboxes, selectionMode]);
  let collection = useCollection(props, (nodes, prev) => new $d7f61bffc1886b961473c48c52f8fd$export$TableCollection(nodes, prev, context), context);
  let {
    disabledKeys,
    selectionManager
  } = useGridState(_babelRuntimeHelpersEsmExtends({}, props, {
    collection
  }));
  return {
    collection,
    disabledKeys,
    selectionManager,
    showSelectionCheckboxes: props.showSelectionCheckboxes || false,
    sortDescriptor: props.sortDescriptor,

    sort(columnKey) {
      var _props$sortDescriptor;

      props.onSortChange({
        column: columnKey,
        direction: ((_props$sortDescriptor = props.sortDescriptor) == null ? void 0 : _props$sortDescriptor.column) === columnKey ? $ed569ec24a699f43593e019ef637b788$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'
      });
    }

  };
}

function $d2418fd9c90ca8bee81eaa89f5a574$var$TableHeader(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$d2418fd9c90ca8bee81eaa89f5a574$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {
  let {
    children,
    columns
  } = props;

  if (typeof children === 'function') {
    if (!columns) {
      throw new Error('props.children was a function but props.columns is missing');
    }

    for (let column of columns) {
      yield {
        type: 'column',
        value: column,
        renderer: children
      };
    }
  } else {
    let columns = [];

    _react.Children.forEach(children, column => {
      columns.push({
        type: 'column',
        element: column
      });
    });

    yield* columns;
  }
};
/**
 * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `columns` prop.
 */
// We don't want getCollectionNode to show up in the type definition


export let TableHeader = $d2418fd9c90ca8bee81eaa89f5a574$var$TableHeader;

function $d42e37bea5d5623bad371e2dcbdc40c5$var$TableBody(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$d42e37bea5d5623bad371e2dcbdc40c5$var$TableBody.getCollectionNode = function* getCollectionNode(props) {
  let {
    children,
    items
  } = props;
  yield {
    type: 'body',
    hasChildNodes: true,
    props,

    *childNodes() {
      if (typeof children === 'function') {
        if (!items) {
          throw new Error('props.children was a function but props.items is missing');
        }

        for (let item of items) {
          yield {
            type: 'item',
            value: item,
            renderer: children
          };
        }
      } else {
        let items = [];

        _react.Children.forEach(children, item => {
          items.push({
            type: 'item',
            element: item
          });
        });

        yield* items;
      }
    }

  };
};
/**
 * A TableBody is a container for the Row elements of a Table. Rows can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `items` prop.
 */
// We don't want getCollectionNode to show up in the type definition


export let TableBody = $d42e37bea5d5623bad371e2dcbdc40c5$var$TableBody;

function $fe0a8908dd4d1a483485d151a57a1f$var$Column(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$fe0a8908dd4d1a483485d151a57a1f$var$Column.getCollectionNode = function* getCollectionNode(props, context) {
  let {
    title,
    children,
    childColumns
  } = props;
  let rendered = title || children;
  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];
  let fullNodes = yield {
    type: 'column',
    hasChildNodes: !!childColumns || title && _react.Children.count(children) > 0,
    rendered,
    textValue,
    props,

    *childNodes() {
      if (childColumns) {
        for (let child of childColumns) {
          yield {
            type: 'column',
            value: child
          };
        }
      } else if (title) {
        let childColumns = [];

        _react.Children.forEach(children, child => {
          childColumns.push({
            type: 'column',
            element: child
          });
        });

        yield* childColumns;
      }
    },

    shouldInvalidate(newContext) {
      // This is a bit of a hack, but it works.
      // If this method is called, then there's a cached version of this node available.
      // But, we need to keep the list of columns in the new context up to date.
      updateContext(newContext);
      return false;
    }

  };

  let updateContext = context => {
    // register leaf columns on the context so that <Row> can access them
    for (let node of fullNodes) {
      if (!node.hasChildNodes) {
        context.columns.push(node);
      }
    }
  };

  updateContext(context);
};
/**
 * A Column represents a field of each item within a Table. Columns may also contain nested
 * Column elements to represent column groups. Nested columns can be statically defined as
 * children, or dynamically generated using a function based on the `childColumns` prop.
 */
// We don't want getCollectionNode to show up in the type definition


export let Column = $fe0a8908dd4d1a483485d151a57a1f$var$Column;

function $a7c409b25db03fac671ec6ef75bead$var$Row(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$a7c409b25db03fac671ec6ef75bead$var$Row.getCollectionNode = function* getCollectionNode(props, context) {
  let {
    children,
    textValue
  } = props;
  yield {
    type: 'item',
    props: props,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: true,

    *childNodes() {
      // Process cells first
      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {
        yield {
          type: 'cell',
          key: 'header',
          // this is combined with the row key by CollectionBuilder
          props: {
            isSelectionCell: true
          }
        };
      }

      if (typeof children === 'function') {
        for (let column of context.columns) {
          yield {
            type: 'cell',
            element: children(column.key),
            key: column.key // this is combined with the row key by CollectionBuilder

          };
        }
      } else {
        let cells = [];

        _react.Children.forEach(children, cell => {
          cells.push({
            type: 'cell',
            element: cell
          });
        });

        if (cells.length !== context.columns.length) {
          throw new Error("Cell count must match column count. Found " + cells.length + " cells and " + context.columns.length + " columns.");
        }

        yield* cells;
      }
    },

    shouldInvalidate(newContext) {
      // Invalidate all rows if the columns changed.
      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;
    }

  };
};
/**
 * A Row represents a single item in a Table and contains Cell elements for each column.
 * Cells can be statically defined as children, or generated dynamically using a function
 * based on the columns defined in the TableHeader.
 */
// We don't want getCollectionNode to show up in the type definition


export let Row = $a7c409b25db03fac671ec6ef75bead$var$Row;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
function $e2fd505f0e5b23b70534674763d176d$var$Cell(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$e2fd505f0e5b23b70534674763d176d$var$Cell.getCollectionNode = function* getCollectionNode(props) {
  let {
    children
  } = props;
  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';
  yield {
    type: 'cell',
    props: props,
    rendered: children,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: false
  };
};
/**
 * A Cell represents the value of a single Column within a Table Row.
 */
// We don't want getCollectionNode to show up in the type definition


export let Cell = $e2fd505f0e5b23b70534674763d176d$var$Cell;
//# sourceMappingURL=module.js.map
