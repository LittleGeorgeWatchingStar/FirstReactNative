{"mappings":"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","sources":["./packages/@react-stately/data/src/useListData.ts","./packages/@react-stately/data/src/useAsyncList.ts","./packages/@react-stately/data/src/useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\ninterface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Key[]): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Key[]): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Key[]) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Key[]) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\ninterface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => Promise<AsyncListStateUpdate<T, C>>;\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\ninterface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\ninterface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\ninterface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children || []\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"],"names":["useListData","options","initialItems","initialSelectedKeys","getKey","item","id","key","filter","initialFilterText","state","setState","useState","items","selectedKeys","Set","filterText","filteredItems","useMemo","createListActions","getItem","find","opts","dispatch","cursor","setSelectedKeys","setFilterText","insert","index","values","insertBefore","findIndex","insertAfter","prepend","append","length","remove","keys","keySet","has","selection","delete","removeSelectedItems","move","toIndex","copy","slice","splice","moveBefore","indices","map","sort","moveAfter","update","newValue","moves","from","to","i","a","j","b","reducer","data","action","type","sortDescriptor","abortController","updater","Error","error","abort","useAsyncList","load","initialSortDescriptor","useReducer","dispatchFetch","fn","AbortController","previousFilterText","response","signal","aborted","e","useEffect","isLoading","loadingState","reload","loadMore","useTreeData","getChildren","children","Map","initialNodes","buildTree","setItems","parentKey","node","value","set","updateTree","get","newNode","deleteNode","addNode","nextParent","c","child","nodes","parentNode","indexOf","newItems","toParentKey","movedNode","oldKey","oldNode"],"version":3,"file":"module.js.map"}